/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SecureBiz mitigration strategy maturity level evaluation API
 * This is the SecureBiz mitigration strategy maturity level evaluation API.
 *
 * OpenAPI spec version: 2.2.1
 * Contact: shijiel@deakin.edu.au
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/jaslian/asd-essential-8/2.2.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * adminlogin
 * @export
 * @interface Adminlogin
 */
export interface Adminlogin {
    /**
     * 
     * @type {string}
     * @memberof Adminlogin
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Adminlogin
     */
    password: string;
}
/**
 * Available Answer of a question
 * @export
 * @interface Answer
 */
export interface Answer {
    /**
     * The value of the option.
     * @type {string | number}
     * @memberof Answer
     */
    value: string | number;
    /**
     * The text showing in the front-end for this option.
     * @type {string}
     * @memberof Answer
     */
    label?: string;
    /**
     * The next question's number if this answer is selected.
     * @type {number}
     * @memberof Answer
     */
    questionNext?: number;
    /**
     * The next core question's number if this answer is selected.
     * @type {number}
     * @memberof Answer
     */
    questionNextCore?: number;
}
/**
 * Answered Questionnaire, basically it's a copy of the original questionnaire with an array of answers that are selected.
 * @export
 * @interface Answersheet
 */
export interface Answersheet {
    /**
     * The questions with the selected answer.
     * @type {Array<Question>}
     * @memberof Answersheet
     */
    questions?: Array<Question>;
}
/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * 
     * @type {Answersheet}
     * @memberof Body
     */
    answers?: Answersheet;
    /**
     * 
     * @type {number}
     * @memberof Body
     */
    level?: number;
}
/**
 * 
 * @export
 * @interface Body1
 */
export interface Body1 {
    /**
     * 
     * @type {string}
     * @memberof Body1
     */
    questionCategory?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Body1
     */
    questionCore?: boolean;
}
/**
 * A strategy category contains a set of questions, this is called questionnaire for most of the specs.
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Id of the category.
     * @type {string}
     * @memberof Category
     */
    id?: string;
    /**
     * This links questions to categories.
     * @type {string}
     * @memberof Category
     */
    questionCategory: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    codeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    title?: string;
    /**
     * This category is visible or hiddend.
     * @type {boolean}
     * @memberof Category
     */
    isVisible?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    tooltip?: string;
    /**
     * URL slug for the category.
     * @type {string}
     * @memberof Category
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    desc?: string;
    /**
     * Long description, this should support RAW HTML.
     * @type {string}
     * @memberof Category
     */
    detailedDesc?: string;
    /**
     * The rules used for calculating the maturity level.
     * @type {Array<Expression>}
     * @memberof Category
     */
    expressions?: Array<Expression>;
    /**
     * 
     * @type {Array<Question>}
     * @memberof Category
     */
    questions?: Array<Question>;
}
/**
 * 
 * @export
 * @interface Expression
 */
export interface Expression {
    /**
     * The operator is used to combine multiple validation rules.
     * @type {string}
     * @memberof Expression
     */
    operator?: Expression.OperatorEnum;
    /**
     * The rules are the conditions to be evaluated against the submitted result. It should be combined using the operator.
     * @type {Array<ModelObject>}
     * @memberof Expression
     */
    rules?: Array<ModelObject>;
    /**
     * The result level associated by the rules.
     * @type {number}
     * @memberof Expression
     */
    level?: number;
    /**
     * The priority of the expression, if override is true, the combined rules will result in returning the level specified, with all the other competing expressions ignored.
     * @type {boolean}
     * @memberof Expression
     */
    override?: boolean;
}

/**
 * @export
 * @namespace Expression
 */
export namespace Expression {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        AND = <any> 'AND',
        OR = <any> 'OR',
        ANYIN = <any> 'ANYIN',
        ALLIN = <any> 'ALLIN',
        IN = <any> 'IN'
    }
}
/**
 * Anonymous feeback
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    content: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * The mitigration level score
     * @type {number}
     * @memberof InlineResponse200
     */
    level?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Total number of feedback found.
     * @type {number}
     * @memberof InlineResponse2001
     */
    total?: number;
    /**
     * all feedback
     * @type {Array<Feedback>}
     * @memberof InlineResponse2001
     */
    feedback?: Array<Feedback>;
}
/**
 * The schema holds the maturity calculation result.
 * @export
 * @interface Maturityresult
 */
export interface Maturityresult {
    /**
     * The maturity level calculated.
     * @type {number}
     * @memberof Maturityresult
     */
    level?: number;
    /**
     * The question category the maturity level is calculated against.
     * @type {string}
     * @memberof Maturityresult
     */
    questionCategory?: string;
}
/**
 * Basic element of a mitigation strategy questionnaire, question has an array property contains possible answers.
 * @export
 * @interface Question
 */
export interface Question {
    /**
     * The unique ID of the question.
     * @type {string}
     * @memberof Question
     */
    id?: string;
    /**
     * Question category, this should match what's in category.
     * @type {string}
     * @memberof Question
     */
    questionCategory?: string;
    /**
     * The label used as in HTML input field's label.
     * @type {string}
     * @memberof Question
     */
    questionLabel?: string;
    /**
     * The question's text, allows RAW HTML.
     * @type {string}
     * @memberof Question
     */
    questionDescription?: string;
    /**
     * The form field type.
     * @type {string}
     * @memberof Question
     */
    questionType?: Question.QuestionTypeEnum;
    /**
     * Mitigation long description.
     * @type {string}
     * @memberof Question
     */
    mitigation?: string;
    /**
     * The question number as in the category. This is different than the question number.
     * @type {number}
     * @memberof Question
     */
    questionSetNumber?: number;
    /**
     * Question number
     * @type {number}
     * @memberof Question
     */
    questionNumber?: number;
    /**
     * Is this question a core qustion?
     * @type {boolean}
     * @memberof Question
     */
    questionCore: boolean;
    /**
     * Question number for core questions. Can be null if it's non-core question.
     * @type {number}
     * @memberof Question
     */
    questionCoreNumber?: number;
    /**
     * The string validation rules.
     * @type {string}
     * @memberof Question
     */
    validators?: string;
    /**
     * Possible answers of the question.
     * @type {Array<Answer>}
     * @memberof Question
     */
    answers?: Array<Answer>;
}

/**
 * @export
 * @namespace Question
 */
export namespace Question {
    /**
     * @export
     * @enum {string}
     */
    export enum QuestionTypeEnum {
        TEXT = <any> 'TEXT',
        MULTIPLE = <any> 'MULTIPLE',
        SELECT = <any> 'SELECT',
        TEXTAREA = <any> 'TEXTAREA',
        BOOLEAN = <any> 'BOOLEAN',
        RADIO = <any> 'RADIO'
    }
}
/**
 * Basic user
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    organisation?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
}
/**
 * AdminsApi - fetch parameter creator
 * @export
 */
export const AdminsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a question
         * @summary Create a question
         * @param {Question} [body] question to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestion(body?: Question, options: any = {}): FetchArgs {
            const localVarPath = `/question`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Question" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a category
         * @summary Add a category
         * @param {Category} [body] category to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestionCategory(body?: Category, options: any = {}): FetchArgs {
            const localVarPath = `/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Category" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * adminlogin
         * @summary admin login
         * @param {Adminlogin} [body] adminlogin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminlogin(body?: Adminlogin, options: any = {}): FetchArgs {
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Adminlogin" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a feedback
         * @summary delete a feedback
         * @param {number} id ID of the feedback to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedback(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFeedback.');
            }
            const localVarPath = `/feedback/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a question
         * @summary Delete a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(questionNumber: number, options: any = {}): FetchArgs {
            // verify required parameter 'questionNumber' is not null or undefined
            if (questionNumber === null || questionNumber === undefined) {
                throw new RequiredError('questionNumber','Required parameter questionNumber was null or undefined when calling deleteQuestion.');
            }
            const localVarPath = `/question/{QuestionNumber}`
                .replace(`{${"QuestionNumber"}}`, encodeURIComponent(String(questionNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a question category, the path param {id} is db collection's system _id.
         * @summary Delete a question category
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionCategory(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteQuestionCategory.');
            }
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an user
         * @summary Delete an user
         * @param {number} id ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUser(options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a question
         * @summary Update a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {Question} [body] question to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestion(questionNumber: number, body?: Question, options: any = {}): FetchArgs {
            // verify required parameter 'questionNumber' is not null or undefined
            if (questionNumber === null || questionNumber === undefined) {
                throw new RequiredError('questionNumber','Required parameter questionNumber was null or undefined when calling updateQuestion.');
            }
            const localVarPath = `/question/{QuestionNumber}`
                .replace(`{${"QuestionNumber"}}`, encodeURIComponent(String(questionNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Question" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a question category, the path param {id} is db collection's system _id.
         * @summary update a question category
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {Category} [body] item to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionCategory(id: string, body?: Category, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateQuestionCategory.');
            }
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Category" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an user
         * @summary Update an user
         * @param {number} id ID of user to patch
         * @param {User} [body] Update an user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, body?: User, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateUser.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminsApi - functional programming interface
 * @export
 */
export const AdminsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a question
         * @summary Create a question
         * @param {Question} [body] question to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestion(body?: Question, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).addQuestion(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add a category
         * @summary Add a category
         * @param {Category} [body] category to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestionCategory(body?: Category, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).addQuestionCategory(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * adminlogin
         * @summary admin login
         * @param {Adminlogin} [body] adminlogin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminlogin(body?: Adminlogin, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).adminlogin(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a feedback
         * @summary delete a feedback
         * @param {number} id ID of the feedback to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedback(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).deleteFeedback(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a question
         * @summary Delete a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(questionNumber: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).deleteQuestion(questionNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a question category, the path param {id} is db collection's system _id.
         * @summary Delete a question category
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionCategory(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).deleteQuestionCategory(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an user
         * @summary Delete an user
         * @param {number} id ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).deleteUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all users
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).getAllUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a question
         * @summary Update a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {Question} [body] question to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestion(questionNumber: number, body?: Question, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).updateQuestion(questionNumber, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add a question category, the path param {id} is db collection's system _id.
         * @summary update a question category
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {Category} [body] item to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionCategory(id: string, body?: Category, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).updateQuestionCategory(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an user
         * @summary Update an user
         * @param {number} id ID of user to patch
         * @param {User} [body] Update an user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, body?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminsApiFetchParamCreator(configuration).updateUser(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminsApi - factory interface
 * @export
 */
export const AdminsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a question
         * @summary Create a question
         * @param {Question} [body] question to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestion(body?: Question, options?: any) {
            return AdminsApiFp(configuration).addQuestion(body, options)(fetch, basePath);
        },
        /**
         * Add a category
         * @summary Add a category
         * @param {Category} [body] category to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addQuestionCategory(body?: Category, options?: any) {
            return AdminsApiFp(configuration).addQuestionCategory(body, options)(fetch, basePath);
        },
        /**
         * adminlogin
         * @summary admin login
         * @param {Adminlogin} [body] adminlogin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminlogin(body?: Adminlogin, options?: any) {
            return AdminsApiFp(configuration).adminlogin(body, options)(fetch, basePath);
        },
        /**
         * Delete a feedback
         * @summary delete a feedback
         * @param {number} id ID of the feedback to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedback(id: number, options?: any) {
            return AdminsApiFp(configuration).deleteFeedback(id, options)(fetch, basePath);
        },
        /**
         * Delete a question
         * @summary Delete a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(questionNumber: number, options?: any) {
            return AdminsApiFp(configuration).deleteQuestion(questionNumber, options)(fetch, basePath);
        },
        /**
         * Delete a question category, the path param {id} is db collection's system _id.
         * @summary Delete a question category
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionCategory(id: string, options?: any) {
            return AdminsApiFp(configuration).deleteQuestionCategory(id, options)(fetch, basePath);
        },
        /**
         * Delete an user
         * @summary Delete an user
         * @param {number} id ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any) {
            return AdminsApiFp(configuration).deleteUser(id, options)(fetch, basePath);
        },
        /**
         * Get all users
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUser(options?: any) {
            return AdminsApiFp(configuration).getAllUser(options)(fetch, basePath);
        },
        /**
         * Update a question
         * @summary Update a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {Question} [body] question to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestion(questionNumber: number, body?: Question, options?: any) {
            return AdminsApiFp(configuration).updateQuestion(questionNumber, body, options)(fetch, basePath);
        },
        /**
         * Add a question category, the path param {id} is db collection's system _id.
         * @summary update a question category
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {Category} [body] item to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionCategory(id: string, body?: Category, options?: any) {
            return AdminsApiFp(configuration).updateQuestionCategory(id, body, options)(fetch, basePath);
        },
        /**
         * Update an user
         * @summary Update an user
         * @param {number} id ID of user to patch
         * @param {User} [body] Update an user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, body?: User, options?: any) {
            return AdminsApiFp(configuration).updateUser(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * AdminsApi - object-oriented interface
 * @export
 * @class AdminsApi
 * @extends {BaseAPI}
 */
export class AdminsApi extends BaseAPI {
    /**
     * Create a question
     * @summary Create a question
     * @param {Question} [body] question to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public addQuestion(body?: Question, options?: any) {
        return AdminsApiFp(this.configuration).addQuestion(body, options)(this.fetch, this.basePath);
    }

    /**
     * Add a category
     * @summary Add a category
     * @param {Category} [body] category to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public addQuestionCategory(body?: Category, options?: any) {
        return AdminsApiFp(this.configuration).addQuestionCategory(body, options)(this.fetch, this.basePath);
    }

    /**
     * adminlogin
     * @summary admin login
     * @param {Adminlogin} [body] adminlogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public adminlogin(body?: Adminlogin, options?: any) {
        return AdminsApiFp(this.configuration).adminlogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a feedback
     * @summary delete a feedback
     * @param {number} id ID of the feedback to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public deleteFeedback(id: number, options?: any) {
        return AdminsApiFp(this.configuration).deleteFeedback(id, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a question
     * @summary Delete a question
     * @param {number} questionNumber Find question with the QuestionNumber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public deleteQuestion(questionNumber: number, options?: any) {
        return AdminsApiFp(this.configuration).deleteQuestion(questionNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a question category, the path param {id} is db collection's system _id.
     * @summary Delete a question category
     * @param {string} id Category&#x27;s collection ID _id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public deleteQuestionCategory(id: string, options?: any) {
        return AdminsApiFp(this.configuration).deleteQuestionCategory(id, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an user
     * @summary Delete an user
     * @param {number} id ID of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public deleteUser(id: number, options?: any) {
        return AdminsApiFp(this.configuration).deleteUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get all users
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public getAllUser(options?: any) {
        return AdminsApiFp(this.configuration).getAllUser(options)(this.fetch, this.basePath);
    }

    /**
     * Update a question
     * @summary Update a question
     * @param {number} questionNumber Find question with the QuestionNumber.
     * @param {Question} [body] question to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public updateQuestion(questionNumber: number, body?: Question, options?: any) {
        return AdminsApiFp(this.configuration).updateQuestion(questionNumber, body, options)(this.fetch, this.basePath);
    }

    /**
     * Add a question category, the path param {id} is db collection's system _id.
     * @summary update a question category
     * @param {string} id Category&#x27;s collection ID _id.
     * @param {Category} [body] item to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public updateQuestionCategory(id: string, body?: Category, options?: any) {
        return AdminsApiFp(this.configuration).updateQuestionCategory(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update an user
     * @summary Update an user
     * @param {number} id ID of user to patch
     * @param {User} [body] Update an user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public updateUser(id: number, body?: User, options?: any) {
        return AdminsApiFp(this.configuration).updateUser(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * PublicApi - fetch parameter creator
 * @export
 */
export const PublicApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add feedback
         * @summary Add feedback
         * @param {Feedback} [body] feedback to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedback(body?: Feedback, options: any = {}): FetchArgs {
            const localVarPath = `/feedback`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an user
         * @summary Add an user
         * @param {User} [body] user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(body?: User, options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary PDF file
         * @summary Get the binary PDF file
         * @param {Body} [body] Request body include an object that has answered questionnaire and the maturity level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePdfReport(body?: Body, options: any = {}): FetchArgs {
            const localVarPath = `/category/result/pdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of feedback
         * @summary Get all feedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFeedback(options: any = {}): FetchArgs {
            const localVarPath = `/feedback-list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all categories
         * @summary Get all categories
         * @param {string} [questionCategory] If QuestionCategory is present, return only specified category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllQuestionCategories(questionCategory?: string, options: any = {}): FetchArgs {
            const localVarPath = `/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (questionCategory !== undefined) {
                localVarQueryParameter['QuestionCategory'] = questionCategory;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all questions
         * @summary Get all questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllQuestions(options: any = {}): FetchArgs {
            const localVarPath = `/questions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get questions based on QuestionCategory and/or QuestionCore query
         * @param {Body1} [body] Request body is an object congtains QuestionCategory string value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryQuestions(body?: Body1, options: any = {}): FetchArgs {
            const localVarPath = `/questions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a feedback
         * @summary Get a feedback
         * @param {number} id ID of the feedback to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFeedback.');
            }
            const localVarPath = `/feedback/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a question by querying QuestionNumber, the param id is the QuestionNumber
         * @summary Get a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestion(questionNumber: number, options: any = {}): FetchArgs {
            // verify required parameter 'questionNumber' is not null or undefined
            if (questionNumber === null || questionNumber === undefined) {
                throw new RequiredError('questionNumber','Required parameter questionNumber was null or undefined when calling getQuestion.');
            }
            const localVarPath = `/question/{QuestionNumber}`
                .replace(`{${"QuestionNumber"}}`, encodeURIComponent(String(questionNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category and its questions, the path param {id} is db collection's system _id.
         * @summary Get a category and its questions
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionCategory(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getQuestionCategory.');
            }
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get one user
         * @summary Get an user
         * @param {number} id ID of user to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUser.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for the Mitigation Maturity level for core questions
         * @param {Answersheet} [body] Query for the Mitigation Maturity level for core questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoryCoreResult(body?: Answersheet, options: any = {}): FetchArgs {
            const localVarPath = `/category/core-result`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Answersheet" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for the Mitigation Maturity level
         * @summary Query for the Mitigation Maturity level
         * @param {string} id Category&#x27;s ObjectId _Id.
         * @param {Answersheet} [body] Query for the Mitigation Maturity level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryQuestionCategoryResult(id: string, body?: Answersheet, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling queryQuestionCategoryResult.');
            }
            const localVarPath = `/category/{id}/result`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add feedback
         * @summary Add feedback
         * @param {Feedback} [body] feedback to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedback(body?: Feedback, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).addFeedback(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add an user
         * @summary Add an user
         * @param {User} [body] user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(body?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).addUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the binary PDF file
         * @summary Get the binary PDF file
         * @param {Body} [body] Request body include an object that has answered questionnaire and the maturity level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePdfReport(body?: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).generatePdfReport(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of feedback
         * @summary Get all feedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFeedback(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getAllFeedback(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all categories
         * @summary Get all categories
         * @param {string} [questionCategory] If QuestionCategory is present, return only specified category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllQuestionCategories(questionCategory?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Category>> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getAllQuestionCategories(questionCategory, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all questions
         * @summary Get all questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllQuestions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Question>> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getAllQuestions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get questions based on QuestionCategory and/or QuestionCore query
         * @param {Body1} [body] Request body is an object congtains QuestionCategory string value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryQuestions(body?: Body1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Question>> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getCategoryQuestions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a feedback
         * @summary Get a feedback
         * @param {number} id ID of the feedback to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getFeedback(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a question by querying QuestionNumber, the param id is the QuestionNumber
         * @summary Get a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestion(questionNumber: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Question> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getQuestion(questionNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a category and its questions, the path param {id} is db collection's system _id.
         * @summary Get a category and its questions
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionCategory(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getQuestionCategory(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get one user
         * @summary Get an user
         * @param {number} id ID of user to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).getUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Query for the Mitigation Maturity level for core questions
         * @param {Answersheet} [body] Query for the Mitigation Maturity level for core questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoryCoreResult(body?: Answersheet, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Maturityresult>> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).postCategoryCoreResult(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Query for the Mitigation Maturity level
         * @summary Query for the Mitigation Maturity level
         * @param {string} id Category&#x27;s ObjectId _Id.
         * @param {Answersheet} [body] Query for the Mitigation Maturity level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryQuestionCategoryResult(id: string, body?: Answersheet, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).queryQuestionCategoryResult(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add feedback
         * @summary Add feedback
         * @param {Feedback} [body] feedback to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedback(body?: Feedback, options?: any) {
            return PublicApiFp(configuration).addFeedback(body, options)(fetch, basePath);
        },
        /**
         * Add an user
         * @summary Add an user
         * @param {User} [body] user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(body?: User, options?: any) {
            return PublicApiFp(configuration).addUser(body, options)(fetch, basePath);
        },
        /**
         * Get the binary PDF file
         * @summary Get the binary PDF file
         * @param {Body} [body] Request body include an object that has answered questionnaire and the maturity level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePdfReport(body?: Body, options?: any) {
            return PublicApiFp(configuration).generatePdfReport(body, options)(fetch, basePath);
        },
        /**
         * Get a list of feedback
         * @summary Get all feedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFeedback(options?: any) {
            return PublicApiFp(configuration).getAllFeedback(options)(fetch, basePath);
        },
        /**
         * Get all categories
         * @summary Get all categories
         * @param {string} [questionCategory] If QuestionCategory is present, return only specified category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllQuestionCategories(questionCategory?: string, options?: any) {
            return PublicApiFp(configuration).getAllQuestionCategories(questionCategory, options)(fetch, basePath);
        },
        /**
         * Get all questions
         * @summary Get all questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllQuestions(options?: any) {
            return PublicApiFp(configuration).getAllQuestions(options)(fetch, basePath);
        },
        /**
         * Get questions based on QuestionCategory and/or QuestionCore query
         * @param {Body1} [body] Request body is an object congtains QuestionCategory string value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryQuestions(body?: Body1, options?: any) {
            return PublicApiFp(configuration).getCategoryQuestions(body, options)(fetch, basePath);
        },
        /**
         * Get a feedback
         * @summary Get a feedback
         * @param {number} id ID of the feedback to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback(id: number, options?: any) {
            return PublicApiFp(configuration).getFeedback(id, options)(fetch, basePath);
        },
        /**
         * Get a question by querying QuestionNumber, the param id is the QuestionNumber
         * @summary Get a question
         * @param {number} questionNumber Find question with the QuestionNumber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestion(questionNumber: number, options?: any) {
            return PublicApiFp(configuration).getQuestion(questionNumber, options)(fetch, basePath);
        },
        /**
         * Get a category and its questions, the path param {id} is db collection's system _id.
         * @summary Get a category and its questions
         * @param {string} id Category&#x27;s collection ID _id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionCategory(id: string, options?: any) {
            return PublicApiFp(configuration).getQuestionCategory(id, options)(fetch, basePath);
        },
        /**
         * Get one user
         * @summary Get an user
         * @param {number} id ID of user to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: any) {
            return PublicApiFp(configuration).getUser(id, options)(fetch, basePath);
        },
        /**
         * Query for the Mitigation Maturity level for core questions
         * @param {Answersheet} [body] Query for the Mitigation Maturity level for core questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoryCoreResult(body?: Answersheet, options?: any) {
            return PublicApiFp(configuration).postCategoryCoreResult(body, options)(fetch, basePath);
        },
        /**
         * Query for the Mitigation Maturity level
         * @summary Query for the Mitigation Maturity level
         * @param {string} id Category&#x27;s ObjectId _Id.
         * @param {Answersheet} [body] Query for the Mitigation Maturity level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryQuestionCategoryResult(id: string, body?: Answersheet, options?: any) {
            return PublicApiFp(configuration).queryQuestionCategoryResult(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * Add feedback
     * @summary Add feedback
     * @param {Feedback} [body] feedback to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public addFeedback(body?: Feedback, options?: any) {
        return PublicApiFp(this.configuration).addFeedback(body, options)(this.fetch, this.basePath);
    }

    /**
     * Add an user
     * @summary Add an user
     * @param {User} [body] user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public addUser(body?: User, options?: any) {
        return PublicApiFp(this.configuration).addUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get the binary PDF file
     * @summary Get the binary PDF file
     * @param {Body} [body] Request body include an object that has answered questionnaire and the maturity level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public generatePdfReport(body?: Body, options?: any) {
        return PublicApiFp(this.configuration).generatePdfReport(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of feedback
     * @summary Get all feedback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getAllFeedback(options?: any) {
        return PublicApiFp(this.configuration).getAllFeedback(options)(this.fetch, this.basePath);
    }

    /**
     * Get all categories
     * @summary Get all categories
     * @param {string} [questionCategory] If QuestionCategory is present, return only specified category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getAllQuestionCategories(questionCategory?: string, options?: any) {
        return PublicApiFp(this.configuration).getAllQuestionCategories(questionCategory, options)(this.fetch, this.basePath);
    }

    /**
     * Get all questions
     * @summary Get all questions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getAllQuestions(options?: any) {
        return PublicApiFp(this.configuration).getAllQuestions(options)(this.fetch, this.basePath);
    }

    /**
     * Get questions based on QuestionCategory and/or QuestionCore query
     * @param {Body1} [body] Request body is an object congtains QuestionCategory string value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getCategoryQuestions(body?: Body1, options?: any) {
        return PublicApiFp(this.configuration).getCategoryQuestions(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a feedback
     * @summary Get a feedback
     * @param {number} id ID of the feedback to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getFeedback(id: number, options?: any) {
        return PublicApiFp(this.configuration).getFeedback(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a question by querying QuestionNumber, the param id is the QuestionNumber
     * @summary Get a question
     * @param {number} questionNumber Find question with the QuestionNumber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getQuestion(questionNumber: number, options?: any) {
        return PublicApiFp(this.configuration).getQuestion(questionNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Get a category and its questions, the path param {id} is db collection's system _id.
     * @summary Get a category and its questions
     * @param {string} id Category&#x27;s collection ID _id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getQuestionCategory(id: string, options?: any) {
        return PublicApiFp(this.configuration).getQuestionCategory(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get one user
     * @summary Get an user
     * @param {number} id ID of user to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getUser(id: number, options?: any) {
        return PublicApiFp(this.configuration).getUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * Query for the Mitigation Maturity level for core questions
     * @param {Answersheet} [body] Query for the Mitigation Maturity level for core questions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public postCategoryCoreResult(body?: Answersheet, options?: any) {
        return PublicApiFp(this.configuration).postCategoryCoreResult(body, options)(this.fetch, this.basePath);
    }

    /**
     * Query for the Mitigation Maturity level
     * @summary Query for the Mitigation Maturity level
     * @param {string} id Category&#x27;s ObjectId _Id.
     * @param {Answersheet} [body] Query for the Mitigation Maturity level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public queryQuestionCategoryResult(id: string, body?: Answersheet, options?: any) {
        return PublicApiFp(this.configuration).queryQuestionCategoryResult(id, body, options)(this.fetch, this.basePath);
    }

}
